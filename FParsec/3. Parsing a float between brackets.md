# Разбор числа с пллавающей точкой между скобками

Реализация парсеров с `FParsec` обычно означает комбинирование высокоуровневых парсеров основанных на парсерах низкого уровня.
Вы начнете с парсеров примитивов предоставляемых библиотекой, а затем будете последовательно их комбинировать их в высокоуровневые до тех пор, пока вы наконец не получите один парсер для полных входных данных.

В этом учебнике мы проиллюстрируем этот подход обсуждением различных простых парсеров, которые строятся друг на друге. 
Начнем с очень простого парсера для числа с плавающей точкой, которое находится между скобками.

```fsharp
let str s = pstring s
let floatBetweenBrackets = str "[" >>. pfloat .>> str "]"
```

**_Примечание_**
> Если при попытке скомпилировать этот или другой пример кода вы получите ошибку "value restriction", пожалуйста обратите внимание на раздел [F#’s value restriction](http://www.quanttec.com/fparsec/tutorial.html#fs-value-restriction)

Определение `str` и `floatBetweenBrackets` включает в себя три библиотечные функции, которые мы еще не представили:
[`pstring`](http://www.quanttec.com/fparsec/reference/charparsers.html#members.pstring),[`>>.`](http://www.quanttec.com/fparsec/reference/primitives.html#members.:62::62:..),[`.>>`](http://www.quanttec.com/fparsec/reference/primitives.html#members...:62::62:)

Функция

```fsharp
val pstring: string -> Parser<string,'u>
```

принимает строку в качестве первого аргумента и возвращает парсер для этой строки.
Когда этот парсер применяется к входному потоку он проверяет совпадают ли символы из входного потока с заданной строкой.
Если символы соответствуют всей строке, парсер поглощает их, т.е. перепригивает через них.  
В противном случае это заканчивается неудачей без поглощения каких-либо входных данных.
Когда разбор успешен, заданная строка тоже возвращается в качестве результата, но поскольку она является константой, вы будете редко её использовать.

Функция `pstring` не названа как `string`, поскольку в противном случае она бы скрыла стандартную F#-функцию `string`. 
Вообще говоря, названия  парсеров из `FParsec` которые могли бы конфликтовать с встроенными функциями из F# начинаются с дополнительного префикса `p`. [pfloat](http://www.quanttec.com/fparsec/reference/charparsers.html#members.pfloat) это еще один пример использования соглашения об именовании.

Для того чтобы немного сократить код, мы переобозначили `pstring` как `str`. То есть, например, `str "["` это парсер, который перепрыгивает через символ `[`.

Бинарные операторы `>>.` и `.>>` имеют следующие типы:

```fsharp
val (>>.): Parser<'a,'u> -> Parser<'b,'u> -> Parser<'b,'u>
val (.>>): Parser<'a,'u> -> Parser<'b,'u> -> Parser<'a,'u>
```

Как вы можете видеть по этим сигнатурам, оба оператора являются парсер-комбинатором что конструирует новый парсер из двух своих аргументов.

Парсер `p1 >>. p2` последовательно парсит `p1` и `p2` и возвращает результат `p2`. 
Парсер `p1 .>> p2` также последовательно парсит `p1` и `p2`, но возвращает результат `p1` вместо `p2`.
В каждом случае точка указывает на сторону того парсера, чей результат возвращается.
Комбинированием обоих операторов в `p1 >>. p2 .>> p3` мы получаем парсер, который последовательно парсит `p1`,`p2` и `p3` и возвращает результат для `p2`.

**_Примечание_**

> В несколько рассплывчатом предложении "последовательно парсит `p1` и `p2`" мы на самом деле имеем ввиду:
> "парсер `p1` применяется к входным данным и если `p1` выполняется успешно, то `p2` применяется к оставшимся входным данным;
> в случае, если любой из двух элементов парсера заканчивается неудачей, результирующий парсер немедленно передает сообщение об ошибке.
>
> В документации для `FParsec` мы часто использум такое выражение как "парсит p" или "парсит вхождение p" вместо технически более аккуратного 
> "применяем парсер `p` к оставшимся входным данным и если `p` выполняется успешно,...", надеемся, что точное значение будет очевидно из контекста.

Следующие тесты показывают, что парсер `floatBetweenBrackets` парсит корректные входные данные как ожидалось и дает информативные сообщения об ошибках в противном случае:


```fsharp
> test floatBetweenBrackets "[1.0]";;
Success: 1.0

> test floatBetweenBrackets "[]";;
Failure: Error in Ln: 1 Col: 2
[]
 ^
Expecting: floating-point number

> test floatBetweenBrackets "[1.0";;
Failure: Error in Ln: 1 Col: 5
[1.0
    ^
Note: The error occurred at the end of the input stream.
Expecting: ']'
```