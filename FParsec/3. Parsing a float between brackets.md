# Parsing a float between brackets

Implementing parsers with FParsec typically means combining higher‐level parsers from lower‐level ones. 
You start with the parser primitives provided by the library and then successively combine these into higher‐level parsers until you finally have a single parser for the complete input.

In the following sections we will illustrate this approach by discussing various sample parsers that build on each other. 
In this section we will begin with a very simple parser for a floating‐point number between brackets:

```fsharp
let str s = pstring s
let floatBetweenBrackets = str "[" >>. pfloat .>> str 
```

>Note
>If you’re trying to compile this or another code snippet and you get a compiler error mentioning F#’s “value restriction”, please see section [4.10](http://www.quanttec.com/fparsec/tutorial.html#fs-value-restriction).

The definition of `str` and `floatBetweenBrackets` involves three library functions that we haven’t yet introduced: 
[pstring](http://www.quanttec.com/fparsec/reference/charparsers.html#members.pstring), [>>.](http://www.quanttec.com/fparsec/reference/primitives.html#members.:62::62:..) and [.>>.](http://www.quanttec.com/fparsec/reference/primitives.html#members...:62::62:)

The function

```fsharp
val pstring: string -> Parser<string,'u>
```

takes a string as the argument and returns a parser for that string. 
When this parser is applied to an input stream it checks whether the following chars in the input stream match the given string. 
If the chars match the complete string, the parser consumes them, i.e. skips over them. 
Otherwise it fails without consuming any input. 
When the parser succeeds, it also returns the given string as the parser result, but since the string is a constant, you’ll rarely make use of the result.

The `pstring` function isn’t named  `string` because otherwise it would hide the built‐in F# function `string`. 
In general, parser names in FParsec that would otherwise conflict with built‐in F# function names are prefixed by a single p char. [pfloat](http://www.quanttec.com/fparsec/reference/charparsers.html#members.pfloat) is another example for this naming convention.

To save a few keystrokes we abbreviate `pstring` as `str`. So, for instance, `str "["` is a parser that skips over the char  '['.

The binary operators `>>.` and `.>>` have the following types:

```fsharp
val (>>.): Parser<'a,'u> -> Parser<'b,'u> -> Parser<'b,'u>
val (.>>): Parser<'a,'u> -> Parser<'b,'u> -> Parser<'a,'u>
```

As you can see from these signatures, both operators are parser combinators that construct a new parser from the two argument parsers. 
The parser `p1 >>. p2` parses `p1` and `p2` in sequence and returns the result of `p2`. 
The parser `p1 .>> p2` also parses `p1` and `p2` in sequence, but it returns the result of `p1` instead of `p2`. 
In each case the point points to the side of the parser whose result is returned. 
By combining both operators in  `p1 >>. p2 .>> p3` we obtain a parser that parses `p1`,`p2` and `p3` in sequence and returns the result from `p2`.

>Note
>
> With the somewhat imprecise wording “parses `p1` and `p2` in sequence” we actually mean: 
> The parser `p1` is applied to the input and if p1 succeeds then `p2` is applied to the remaining input; 
> in case any of the two element parsers fails, the aggregate parser immediately propagates the error message.
> In the documentation for FParsec we often use expressions such as “parses `p`” or “parses an occurrence of `p`” instead of the technically more accurate 
> “applies the parser `p` to the remaining input and if `p` succeeds …”, hoping that the exact meaning is obvious from the context.

The following tests show that `floatBetweenBrackets` parses valid input as expected and produces informative error messages when it encounters invalid input:

```fsharp
> test floatBetweenBrackets "[1.0]";;
Success: 1.0

> test floatBetweenBrackets "[]";;
Failure: Error in Ln: 1 Col: 2
[]
 ^
Expecting: floating-point number

> test floatBetweenBrackets "[1.0";;
Failure: Error in Ln: 1 Col: 5
[1.0
    ^
Note: The error occurred at the end of the input stream.
Expecting: ']'
```