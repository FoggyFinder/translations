# Абстрактные парсеры

Одна из самых сильных сторон `FParsec` - легкость с которой вы можете определить ваш собственный абстрактный парсер.

Возьмем, к примеру, `floatBetweenBrackets` из предыдущей главы. 
Если вы намерены также разбирать другие элементы между строк, то для этого вы можете определить собственный специализированный комбинатор:

```fsharp
let betweenStrings s1 s2 p = str s1 >>. p .>> str s2
```

Теперь вы можете определить `floatInBrackets` и другие парсеры с помощью этого комбинатора:

```fsharp
let floatBetweenBrackets = pfloat |> betweenStrings "[" "]"
let floatBetweenDoubleBrackets = pfloat |> betweenStrings "[[" "]]"
```

**_Примечание_**

>В том случае, если вы новичок в F#:
>```fsharp
>pfloat |> betweenStrings "[" "]"
>```
>это просто другая форма записи для 
>```fsharp
>betweenStrings "[" "]" pfloat
>```

Как только вы заметите, что вам часто нужно применять парсер между двумя другими, вы можете пойти на шаг дальше и "вынести за скобки" `betweenStrings` следующим образом:

```fsharp
let between pBegin pEnd p  = pBegin >>. p .>> pEnd
let betweenStrings s1 s2 p = p |> between (str s1) (str s2)
```

На самом деле, вам не нужно определять `between`, т.к. такой комбинатор уже [есть](http://www.quanttec.com/fparsec/reference/primitives.html#members.between) в библиотеке `FParsec`.

Конечно, все эти примеры тривиальны. Но, поскольку, `FParsec` это только F#-библиотека, а не какой-нибудь внешний инструмент для генерации парсеров, здесь  нет ограничений на абстракции, которые вы можете определить.
Вы можете написать функцию, которая принимает те входные данные которые вам нужны, выполняет некоторые сложные произвольные вычисления и затем возвращаем парсер специального назначения или парсер-комбинатор.

Например, вы можете написать функцию, которая принимает паттерн регулярного выражения в качестве входного параметра и в соответствии с ним возвращает `Parser` для разбора данных. 
Эта функция может использовать другой парсер для разбора шаблона в [АСД](https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево) а затем компилировать его в специальную функцию парсинга.
В качестве альтернативы можно построить регулярное выражение .Net из шаблона и затем вернуть функцию-парсер, которая использует `CharStream` API из `FParsec` для того, чтобы непосредственно применить регулярное выражение к входному потому (на самом деле это как раз то, что делает встроенный парсер [regex](http://www.quanttec.com/fparsec/reference/charparsers.html#members.regex)).

Другой пример - расширяемое приложение-парсер. 
Сохранив функции парсинга в словаре или другой структуре данных и определив расширяющий протокол, вы можете позволить плагину динамически регистрировать новые парсеры или изменять существующие.

Возможности действительно неограниченны. Но, прежде, чем вы сможете полностью их использовать, вам нужно познакомиться с основами `FParsec`.
